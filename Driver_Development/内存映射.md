-----------
title: 内存映射  
-----------  
**在学习块设备的过程中发现对linux内存以及底层的存储空间了解甚少，所以来学习一下**  


<!--more-->  


# Linux的内存管理
## 地址类型
Linux是一个虚拟内存系统，这意味着用户程序所使用的地址与硬件锁使用的物理地址是不等同的，虚拟内存引入了一个间接层。有了虚拟内存，在系统中的程序可以分配比物理内存更多的内存。  
<font color=Red>Linux使用的地址类型列表</font>   
1. 用户虚拟地址：这是用户空间程序所能看到的常规地址  
2. 物理地址：该地址在处理器和系统内存之间使用  
3. 总线地址：该地址在外围总线和内存之间使用  
4. 内核逻辑地址:内核逻辑地址组成了内核的常规地址空间。该地址映射了部分（或者全部）内存，并经常被视为物理地址。<font color=bule>逻辑地址和与其相关联的物理地址的不同是两者之间存在一个固定的偏移量</font>。kmalloc返回的内存就是内核逻辑地址  
5. 内核虚拟地址：内核虚拟地址和逻辑地址相同之处在于他们呢都将内核空间的地址映射到物理地址上。不相同之处是内核逻辑地址与逻辑地址是一一对应的而内核虚拟地址不是一一对应的。所有的逻辑地址都是内核虚拟地址，而所有内核虚拟地址不是逻辑地址  

# 内核空间和用户空间
内核将4G虚拟地址空间分割为用户空间（3G）和内核空间(1G)(可以重新分配)   
<font color=Red>内核空间</font>：内核空间是操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。   
<font color=Red>用户空间</font>：用户空间是普通应用程序可访问的内存区域。  
![image](https://pic4.zhimg.com/v2-f7d5d36ac5eee4fadd43e9d064e267cf_r.jpg)
### 内核空间和用户空间的数据交换
* 内核空间和用户空间的数据交换需要通过专有函数完成。  

		unsigned copy_to_user(void __user *to,const* void *from,unsigned long count); 
		unsigned copy_from _user(void *to,const* void __user   *from,unsigned long count);

* 逻辑地址到物理地址的转换  
	内核访问到的地址都是逻辑地址，CPU在拿到逻辑地址后转化为对应的线性地址，然后线性地址再通过页表转换成物理地址。物理地址的数据才是要访问的数据  
	内核对所有地址的访问都必须通过虚拟地址来访问  
* 内存管理单元（MMU）：管理内存并把虚拟地址转换为物理地址的硬件（以页来处理）  
#### 段页式内存管理和页表映射机制
页：物理地址被分成离散的单元，称之为页。系统内部许多对内存的操作都是基于单个页的，每个页的大小随体系架构的不同而不同。PAGE_SIZE(在asm/page.h中定义)给出了在任何指定体系架构下页的大小。内核用struct page结构表示系统中的每个页（Linux/mm_types.h）  
**高端内存与低端内存**：只有内存的低端部分拥有逻辑地址，内存的高端部分是没有逻辑地址的，在访问特定的高端内存页前，内核必须建立明确的虚拟映射，使该页在内核地址空间中可以被访问。


### kmalloc 与 vmalloc
**kmalloc**:分配连续的物理地址，虚拟地址自然也是连续的，一般用于申请小于一页的物理内存  
	
	void *kmalloc(size_t size, int flags)  
	flags:
	GFP_KERNEL:是代表运行在内核空间的进程执行的 （最常用的）  使用这个标志意味着kmalloc在空闲内存较少时把当前进程转入休眠来等待一个页 
	GFP_ATOMIC:例如在中断处理程序、tasklet以及内核定时器中调用kmalloc时，进程不应该被休眠。所以应该使用这个参数  
	
**vmalloc** 分配连续的内存虚拟地址上是连续的，但是物理地址不是连续的，一般用于申请大块内存  

	void *vmalloc(unsigned long size)     
